<script>
const BASE_CONFIG_URL = "https://eduwonderlab.com/configs/";
const SHEET_URL = "PASTE_YOUR_CSV_LINK_HERE"; // must end with output=csv

// Robust CSV parser (handles quotes + commas inside quotes)
function parseCSV(csvText) {
  const rows = [];
  let row = [];
  let cur = "";
  let inQuotes = false;

  for (let i = 0; i < csvText.length; i++) {
    const ch = csvText[i];
    const next = csvText[i + 1];

    if (ch === '"' && inQuotes && next === '"') { // escaped quote
      cur += '"';
      i++;
      continue;
    }
    if (ch === '"') {
      inQuotes = !inQuotes;
      continue;
    }
    if (ch === "," && !inQuotes) {
      row.push(cur);
      cur = "";
      continue;
    }
    if ((ch === "\n" || ch === "\r") && !inQuotes) {
      if (ch === "\r" && next === "\n") i++; // handle CRLF
      row.push(cur);
      cur = "";
      if (row.some(v => v.trim() !== "")) rows.push(row);
      row = [];
      continue;
    }
    cur += ch;
  }
  row.push(cur);
  if (row.some(v => v.trim() !== "")) rows.push(row);

  return rows;
}

async function loadSheetData() {
  // cache-buster so Google Sites + browsers donâ€™t serve stale sheet content
  const url = SHEET_URL + (SHEET_URL.includes("?") ? "&" : "?") + "t=" + Date.now();
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error("Sheet fetch failed: " + res.status);

  const text = await res.text();
  const table = parseCSV(text.trim());
  if (!table.length) return [];

  const headers = table[0].map(h => h.trim());
  const dataRows = table.slice(1);

  return dataRows.map(r => {
    const obj = {};
    headers.forEach((h, i) => (obj[h] = (r[i] ?? "").trim()));
    return obj;
  });
}

// âœ… Your existing hardcoded data stays as fallback
const GAMES = [ /* ... keep your big GAMES array exactly as-is ... */ ];

const ENGINE_LABELS = {
  "E1_SortMatch": "Sort & Match",
  "E2_ModelBuilder": "Model Builder",
  "E3_ScenarioSim": "Scenario Sim",
  "E4_ErrorCourt": "Error Court"
};

const DOMAIN_ICONS = {
  "Ratios & Proportions": "âš–ï¸",
  "Number System": "ðŸ”¢",
  "Expressions & Equations": "ðŸ”£",
  "Geometry": "ðŸ“",
  "Statistics & Probability": "ðŸ“Š"
};

function gameUrl(g) {
  if (!g.engineUrl || !g.configFile) return null;
  return `${g.engineUrl}?configUrl=${BASE_CONFIG_URL}${g.configFile}&standard=${g.standard}&wida=3-4`;
}

function renderCard(g) {
  const url = gameUrl(g);
  const isBuilt = g.status === "built";
  const miscHtml = (g.misconceptions || []).map(m => `<span>${String(m).replace("ERR:","")} âš </span>`).join("");

  return `
    <div class="game-card status-${String(g.status || "").replace(" ","-")}" data-domain="${g.domain}" data-title="${(g.title||"").toLowerCase()} ${(g.standard||"").toLowerCase()} ${(g.skill||"").toLowerCase()}">
      <div class="card-top">
        <span class="standard-badge">${g.standard || ""}</span>
        <div class="status-dot ${isBuilt ? "built" : "not-built"}" title="${isBuilt ? "Live" : "Coming Soon"}"></div>
      </div>
      <div class="game-title">${g.title || ""}</div>
      <div class="game-skill">${g.skill || ""}</div>
      <div class="card-meta">
        <span class="meta-chip engine">${ENGINE_LABELS[g.engine] || g.engine || ""}</span>
        <span class="meta-chip dok">${g.dok || ""}</span>
        <span class="meta-chip wida">${g.wida || ""}</span>
      </div>
      <div class="misconceptions">${miscHtml}</div>
      <div class="card-actions">
        ${isBuilt && url
          ? `<a class="play-btn available" href="${url}" target="_blank" rel="noopener">â–¶ Play Now</a>`
          : `<span class="play-btn coming-soon">ðŸ”§ Coming Soon</span>`
        }
      </div>
    </div>`;
}

function renderAll(games) {
  const container = document.getElementById("gameContainer");
  container.innerHTML = "";

  const byDomain = {};
  for (const g of games) {
    if (!byDomain[g.domain]) byDomain[g.domain] = [];
    byDomain[g.domain].push(g);
  }

  const domainOrder = ["Ratios & Proportions", "Number System", "Expressions & Equations", "Geometry", "Statistics & Probability"];

  for (const domain of domainOrder) {
    const list = byDomain[domain];
    if (!list || !list.length) continue;

    const section = document.createElement("div");
    section.className = "domain-section";
    const built = list.filter(g => g.status === "built").length;

    section.innerHTML = `
      <div class="domain-header">
        <span class="domain-icon">${DOMAIN_ICONS[domain] || "ðŸ“š"}</span>
        <span class="domain-title">${domain}</span>
        <span class="domain-count">${built}/${list.length} live</span>
      </div>
      <div class="games-grid">${list.map(renderCard).join("")}</div>`;
    container.appendChild(section);
  }

  const total = games.length;
  const builtCount = games.filter(g => g.status === "built").length;
  document.getElementById("statTotal").textContent = total;
  document.getElementById("statBuilt").textContent = builtCount;
  document.getElementById("statComing").textContent = total - builtCount;
}

// Filters + Search stay the same as your current code (keep them)

// âœ… Boot: try sheet first; fall back to built-in GAMES if sheet fails
(async function boot() {
  try {
    const sheetData = await loadSheetData();
    console.log("Sheet loaded:", sheetData);

    // If your sheet rows match the game object shape, use them; otherwise fallback
    if (Array.isArray(sheetData) && sheetData.length) {
      renderAll(sheetData);
      return;
    }
  } catch (e) {
    console.warn("Sheet load failed, using built-in GAMES:", e);
  }

  renderAll(GAMES);
})();
</script>
